

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Chapter 12: Improving Rendering Efficiency &mdash; OpenSceneGraph 3.0 Beginner&#39;s Guide 0.01 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/labibi.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="OpenSceneGraph 3.0 Beginner&#39;s Guide 0.01 documentation" href="index.html"/>
        <link rel="prev" title="Chapter 11: Developing Visual Components" href="ch11.html"/>



  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="index.html" class="fa fa-home"> OpenSceneGraph 3.0 Beginner's Guide</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="ch01.html">Chapter 1: The Journey into OpenSceneGraph</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch02.html">Chapter 2: Compilation and Installation of OpenSceneGraph</a></li>
<li class="toctree-l1"><a class="reference internal" href="ch03.html">Chapter 3: Creating Your First OSG Program</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ch03.html#constructing-your-own-projects">Constructing your own projects</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch03.html#using-a-root-node">Using a root node</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch03.html#understanding-memory-management">Understanding memory management</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch03.html#ref-ptr-and-referenced-classes">ref_ptr&lt;&gt; and Referenced classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch03.html#collecting-garbage-why-and-how">Collecting garbage: why and how</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch03.html#tracing-the-managed-entities">Tracing the managed entities</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch03.html#parsing-command-line-arguments">Parsing command-line arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch03.html#tracing-with-the-notifier">Tracing with the notifier</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch03.html#redirecting-the-notifier">Redirecting the notifier</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch03.html#summary">Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ch04.html">Chapter 4: Building Geometry Models</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ch04.html#how-opengl-draws-objects">How OpenGL draws objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch04.html#geode-and-drawable-classes">Geode and Drawable classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch04.html#rendering-basic-shapes">Rendering basic shapes</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch04.html#storing-array-data">Storing array data</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch04.html#vertices-and-vertex-attributes">Vertices and vertex attributes</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch04.html#specifying-drawing-types">Specifying drawing types</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch04.html#indexing-primitives">Indexing primitives</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch04.html#using-polygonal-techniques">Using polygonal techniques</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch04.html#rereading-geometry-attributes">Rereading geometry attributes</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch04.html#customizing-a-primitive-functor">Customizing a primitive functor</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch04.html#implementing-your-own-drawables">Implementing your own drawables</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch04.html#using-opengl-drawing-calls">Using OpenGL drawing calls</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch04.html#summary">Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ch05.html">Chapter 5: Managing Scene Graph</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ch05.html#the-group-interface">The Group interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch05.html#managing-parent-nodes">Managing parent nodes</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch05.html#traversing-the-scene-graph">Traversing the scene graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch05.html#transformation-nodes">Transformation nodes</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch05.html#understanding-the-matrix">Understanding the matrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch05.html#the-matrix-transform-class">The Matrix Transform class</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch05.html#switch-nodes">Switch nodes</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch05.html#level-of-detail-nodes">Level-of-detail nodes</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch05.html#proxy-and-paging-nodes">Proxy and paging nodes</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch05.html#customizing-your-own-nodekits">Customizing your own NodeKits</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch05.html#the-visitor-design-pattern">The visitor design pattern</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch05.html#visiting-scene-graph-structures">Visiting scene graph structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch05.html#summary">Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ch06.html">Chapter 6: Creating Realistic Rendering Effects</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ch06.html#encapsulating-the-opengl-state-machine">Encapsulating the OpenGL state machine</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch06.html#attributes-and-modes">Attributes and modes</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch06.html#inheriting-render-states">Inheriting render states</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch06.html#playing-with-fixed-function-effects">Playing with fixed-function effects</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch06.html#lights-and-light-sources">Lights and light sources</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch06.html#the-image-class">The Image class</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch06.html#the-basis-of-texture-mapping">The basis of texture mapping</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch06.html#handling-rendering-order">Handling rendering order</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch06.html#understanding-graphics-shaders">Understanding graphics shaders</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch06.html#using-uniforms">Using uniforms</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch06.html#working-with-the-geometry-shader">Working with the geometry shader</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch06.html#summary">Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ch07.html">Chapter 7: Viewing the World</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ch07.html#from-world-to-screen">From world to screen</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch07.html#the-camera-class">The Camera class</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch07.html#rendering-order-of-cameras">Rendering order of cameras</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch07.html#using-a-single-viewer">Using a single viewer</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch07.html#digging-into-the-simulation-loop">Digging into the simulation loop</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch07.html#using-a-composite-viewer">Using a composite viewer</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch07.html#changing-global-display-settings">Changing global display settings</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch07.html#stereo-visualization">Stereo visualization</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch07.html#rendering-to-textures">Rendering to textures</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch07.html#frame-buffer-pixel-buffer-and-fbo">Frame buffer, pixel buffer, and FBO</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch07.html#summary">Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ch08.html">Chapter 8: Animating Scene Objects</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ch08.html#taking-references-to-functions">Taking references to functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch08.html#list-of-callbacks">List of callbacks</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch08.html#avoding-confilicting-modifications">Avoding confilicting modifications</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch08.html#understanding-ease-motions">Understanding ease motions</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch08.html#animating-the-transformation-nodes">Animating the transformation nodes</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch08.html#changing-rendering-states">Changing rendering states</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch08.html#playing-movies-on-textures">Playing movies on textures</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch08.html#creating-complex-key-frame-animations">Creating complex key-frame animations</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch08.html#channels-and-animation-managers">Channels and animation managers</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch08.html#loading-and-rendering-characters">Loading and rendering characters</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch08.html#summary">Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ch09.html">Chatper 9: Interacting with Outside Elements</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ch09.html#various-events">Various events</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch09.html#handling-mouse-and-keyboard-inputs">Handling mouse and keyboard inputs</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch09.html#adding-customized-events">Adding customized events</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch09.html#picking-objects">Picking objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch09.html#intersection">Intersection</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch09.html#windows-graphics-contexts-and-cameras">Windows, graphics contexts, and cameras</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch09.html#the-traits-class">The Traits class</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch09.html#integrating-osg-into-a-window">Integrating OSG into a window</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch09.html#summary">Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ch10.html">Chapter 10: Saving and Loading Files</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ch10.html#understanding-file-i-o-plugins">Understanding file I/O plugins</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch10.html#discovery-of-specified-extension">Discovery of specified extension</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch10.html#supported-file-formats">Supported file formats</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch10.html#the-pseudo-loader">The pseudo-loader</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch10.html#configuring-third-party-dependencies">Configuring third-party dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch10.html#writing-your-own-plugins">Writing your own plugins</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch10.html#handling-the-data-stream">Handling the data stream</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch10.html#serializing-osg-native-scenes">Serializing OSG native scenes</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch10.html#creating-serializers">Creating serializers</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch10.html#summary">Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ch11.html">Chapter 11: Developing Visual Components</a><ul>
<li class="toctree-l2"><a class="reference internal" href="ch11.html#creating-billboards-in-a-scene">Creating billboards in a scene</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch11.html#creating-texts">Creating texts</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch11.html#creating-3d-texts">Creating 3D texts</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch11.html#creating-particle-animations">Creating particle animations</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch11.html#creating-shadows-on-the-ground">Creating shadows on the ground</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch11.html#implementing-special-effects">Implementing special effects</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch11.html#playing-with-more-nodekits">Playing with more NodeKits</a></li>
<li class="toctree-l2"><a class="reference internal" href="ch11.html#summary">Summary</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Chapter 12: Improving Rendering Efficiency</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#open-threads-basics">Open Threads basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="#understanding-multithreaded-readering">Understanding multithreaded readering</a></li>
<li class="toctree-l2"><a class="reference internal" href="#dynamic-scene-culling">Dynamic scene culling</a></li>
<li class="toctree-l2"><a class="reference internal" href="#occluders-and-occludees">Occluders and occludees</a></li>
<li class="toctree-l2"><a class="reference internal" href="#improving-your-application">Improving your application</a></li>
<li class="toctree-l2"><a class="reference internal" href="#paging-huge-scene-data">Paging huge scene data</a></li>
<li class="toctree-l2"><a class="reference internal" href="#making-use-of-the-quad-tree">Making use of the quad-tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="#summary">Summary</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">OpenSceneGraph 3.0 Beginner's Guide</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Chapter 12: Improving Rendering Efficiency</li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="_sources/ch12.rst.txt" rel="nofollow"> View page source</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            
  
  <div class="section" id="chapter-12-improving-rendering-efficiency">
<h1>Chapter 12: Improving Rendering Efficiency<a class="headerlink" href="#chapter-12-improving-rendering-efficiency" title="Permalink to this headline">¶</a></h1>
<p>在本书的最后一章，我们将介绍用于构建快速，实时渲染系统所需要的技术，从而以一种高效的方式帮助用户载入，组织与渲染大规模数据集。理解一个较大API调用集合的所有类，方法与全局变量相对较为容易，但是将我们所学的内容应用实际应用，正确且高效的方式，则是另一回事。这里改善渲染效率的方法也许有助于解决我们时不时会遇到的某些引擎问题。</p>
<p>在本章中，我们将会了解：</p>
<ul class="simple">
<li><p>在OSG中实现多线程操作与渲染的基本原则</p></li>
<li><p>场景裁剪与闭塞裁剪的概念</p></li>
<li><p>通过修改与共享几何体与纹理改善渲染性的不同方法</p></li>
<li><p>在处理大数据集时的动态分页机制及其应用</p></li>
</ul>
<div class="section" id="open-threads-basics">
<h2>Open Threads basics<a class="headerlink" href="#open-threads-basics" title="Permalink to this headline">¶</a></h2>
<p>OpenThreads是一个用于OSG类与应用的一个轻量级，跨平台的API。他支持一个多线程程序所需要的基本元素，也就是，线程对象（OpenThreads::Thread），用于锁住不同线程共享数据的信号量（OpenThreads::Mutex），边界（OpenThreads::Barrier），以及条件（OpenThreads::Condition）。后两者经常用于线程同步。</p>
<p>为某一目的创建新线程，我们需要派生OpenThreads::Thread基类并重新实现其虚方法。还有一些方便处理线程与线程属性的全局函数，例如：</p>
<ul class="simple">
<li><p>GetNumberOfProcessors()函数获取可用的处理器数量</p></li>
<li><p>SetProcessorAffinityOfCurrentThread()函数设置处理与当前线程的关系（也就是，哪一个处理器用来执行当前线程）。他应在线程当前运行时调用。</p></li>
<li><p>OpenThreads::Thread的CurrentThread()静态函数返回指向当前运行线程实例的指针。</p></li>
<li><p>OpenThreads::Thread的YieldCurrentThread()静态函数获取当前线程并且让其他线程接管处理器的控制。</p></li>
<li><p>OpenThreads::Thread的microSleep()静态方法使得当前线程睡眠指定的毫秒数。他也可以用在单线程程序中。</p></li>
</ul>
<div class="section" id="time-for-action-using-a-separate-data-receiver-thread">
<h3>Time for action - using a separate data receiver thread<a class="headerlink" href="#time-for-action-using-a-separate-data-receiver-thread" title="Permalink to this headline">¶</a></h3>
<p>在该示例中，我们将使用OpenThreads库设计一个新线程，并用来由标准输入读取字符。同时，主进程，也就是，OSG查看器与渲染后端将会接收输入字符并使用osgText库在屏幕上进行显示。只有当数据线程与主进程同时完成时，整个程序才会正常退出。</p>
<ol class="arabic simple">
<li><p>包含必须的头文件：</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;osg/Geode&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;osgDB/ReadFile&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;osgText/Text&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;osgViewer/Viewer&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>声明一个新的DataReceiverThread类作为OpenThread::Thread类的派生类。在该类中需要实现两个新方法以确保线程可以正常工作：cancel()方法定义了线程的关闭处理，而run()方法定义了由线程的开始到结束所发生的动作。我们同时定义了一个mutex变量用于线程间同步，并有为了方便使用单例模式：</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">DataReceiverThread</span> <span class="o">:</span> <span class="k">public</span> <span class="n">OpenThreads</span><span class="o">::</span><span class="n">Thread</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">static</span> <span class="n">DataReceiverThread</span><span class="o">*</span> <span class="n">instance</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="n">DataReceiverThread</span> <span class="n">s_thread</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">&amp;</span><span class="n">s_thread</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">cancel</span><span class="p">();</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">run</span><span class="p">();</span>

    <span class="kt">void</span> <span class="nf">addToContent</span><span class="p">(</span> <span class="kt">int</span> <span class="n">ch</span> <span class="p">);</span>
    <span class="kt">bool</span> <span class="nf">getContent</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span> <span class="p">);</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="n">OpenThreads</span><span class="o">::</span><span class="n">Mutex</span> <span class="n">_mutex</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">_content</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">_done</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">_dirty</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<ol class="arabic simple" start="3">
<li><p>关闭处理非常简单：设置变量_done（在run()实现中重复检测直到为true）并等待线程完成：</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">DataReceiverThread</span><span class="o">::</span><span class="n">cancel</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">_done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span> <span class="n">isRunning</span><span class="p">()</span> <span class="p">)</span> <span class="n">YieldCurrentThread</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<ol class="arabic simple" start="4">
<li><p>run()方法是线程类的核心。他通常包含一个循环，在其中执行实际的处理动作。在我们的数据接收线程中，我们使用std::cin.get()来由键盘输入读取字符并且确定是否可以添加到成员字符串_content中。当_done被设置为true时，run()方法结束生命周期，而整个线程也同样如此：</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">DataReceiverThread</span><span class="o">::</span><span class="n">run</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">_done</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">_dirty</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">do</span>
    <span class="p">{</span>
        <span class="n">YieldCurrentThread</span><span class="p">();</span>

        <span class="kt">int</span> <span class="n">ch</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">ch</span><span class="p">)</span>
        <span class="p">{</span>
        <span class="k">case</span> <span class="mi">0</span><span class="o">:</span> <span class="k">break</span><span class="p">;</span>  <span class="c1">// We don&#39;t want &#39;\0&#39; to be added</span>
        <span class="k">case</span> <span class="mi">9</span><span class="o">:</span> <span class="n">_done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>  <span class="c1">// ASCII code of Tab = 9</span>
        <span class="k">default</span><span class="o">:</span> <span class="n">addToContent</span><span class="p">(</span><span class="n">ch</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">while</span><span class="p">(</span> <span class="o">!</span><span class="n">_done</span> <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<ol class="arabic simple" start="5">
<li><p>在这里要小心std::cin.get()函数：他首先由用户输入读取一个或多个字符，直到回车键被按下并接收到’n’为止。然后，他由缓冲区中一次选取一个字符，并连续将其添加到成员字符串中。当缓冲区中的所有字符都遍历完成后，他会清空缓冲区并再次等待用户输入。</p></li>
<li><p>自定义的addToContent()方法向_content添加新字符。该方法当然是在数据接收者线程中被调用的，所以当我们改变_content变量时，我们必须锁定mutex对象，来避免其他线程与主进程污染该变量：</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">DataReceiverThread</span><span class="o">::</span><span class="n">addToContent</span><span class="p">(</span> <span class="kt">int</span> <span class="n">ch</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">OpenThreads</span><span class="o">::</span><span class="n">ScopedLock</span><span class="o">&lt;</span><span class="n">OpenThreads</span><span class="o">::</span><span class="n">Mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">_mutex</span><span class="p">);</span>
    <span class="n">_content</span> <span class="o">+=</span> <span class="n">ch</span><span class="p">;</span>
    <span class="n">_dirty</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<ol class="arabic simple" start="7">
<li><p>自定义的getContent()方法被用来获取_content变量并将其添加到输入字符串参数。该方法是前面addToContent()方法的逆操作，只能在后续的OSG回调实现中调用。互斥（mutex）对象的作用域锁定操作将会使得整个处理是线程安全的，就如是addToContent()中的处理一样：</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">getContent</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">OpenThreads</span><span class="o">::</span><span class="n">ScopedLock</span><span class="o">&lt;</span><span class="n">OpenThreads</span><span class="o">::</span><span class="n">Mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">_mutex</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">_dirty</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">str</span> <span class="o">+=</span> <span class="n">_content</span><span class="p">;</span>
        <span class="n">_dirty</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<ol class="arabic simple" start="8">
<li><p>线程实现完成了。现在让我们回到渲染。这里我们所希望的是一个可以依据由主进程中接收到的字符串而动态改变其内容的文本对象。文本对象的更新回调对于实现该功能是必须的。在自定义的更新回调的虚update()方法中（用于可绘制元素，所以这里不需要osg::NodeCallback），我们简单的接收osgText::Text对象以及接收器线程实例，然后重置所显示的文本：</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">UpdateTextCallback</span> <span class="o">:</span> <span class="k">public</span> <span class="n">osg</span><span class="o">::</span><span class="n">Drawable</span><span class="o">::</span><span class="n">UpdateCallback</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span> <span class="n">osg</span><span class="o">::</span><span class="n">NodeVisitor</span><span class="o">*</span> <span class="n">nv</span><span class="p">,</span>
                         <span class="n">osg</span><span class="o">::</span><span class="n">Drawable</span><span class="o">*</span> <span class="n">drawable</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">osgText</span><span class="o">::</span><span class="n">Text</span><span class="o">*</span> <span class="n">text</span> <span class="o">=</span>
            <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">osgText</span><span class="o">::</span><span class="n">Text</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">drawable</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">text</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">(</span><span class="s">&quot;# &quot;</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">DataReceiverThread</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getContent</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="p">)</span>
                <span class="n">text</span><span class="o">-&gt;</span><span class="n">setText</span><span class="p">(</span> <span class="n">str</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<ol class="arabic simple" start="9">
<li><p>在主体部分，我们首先创建osgText::Text可绘制元素，并且应我们文本更新回调的实例。这里setAxisAlignment()将文本定义为场景中的公告板，而setDataVariance()确保文本对象在更新与绘制过程中是动态更新的。同时还有一个setInitialBound()方法，该方法接受osg::BoundingBox变量作为参数。他会强制可绘制元素最小边界框的定义，并依此计算初始视图矩阵：</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">osg</span><span class="o">::</span><span class="n">ref_ptr</span><span class="o">&lt;</span><span class="n">osgText</span><span class="o">::</span><span class="n">Text</span><span class="o">&gt;</span> <span class="n">text</span> <span class="o">=</span> <span class="k">new</span> <span class="n">osgText</span><span class="o">::</span><span class="n">Text</span><span class="p">;</span>
<span class="n">text</span><span class="o">-&gt;</span><span class="n">setFont</span><span class="p">(</span> <span class="s">&quot;fonts/arial.ttf&quot;</span> <span class="p">);</span>
<span class="n">text</span><span class="o">-&gt;</span><span class="n">setAxisAlignment</span><span class="p">(</span> <span class="n">osgText</span><span class="o">::</span><span class="n">TextBase</span><span class="o">::</span><span class="n">SCREEN</span> <span class="p">);</span>
<span class="n">text</span><span class="o">-&gt;</span><span class="n">setDataVariance</span><span class="p">(</span> <span class="n">osg</span><span class="o">::</span><span class="n">Object</span><span class="o">::</span><span class="n">DYNAMIC</span> <span class="p">);</span>
<span class="n">text</span><span class="o">-&gt;</span><span class="n">setInitialBound</span><span class="p">(</span>
    <span class="n">osg</span><span class="o">::</span><span class="n">BoundingBox</span><span class="p">(</span><span class="n">osg</span><span class="o">::</span><span class="n">Vec3</span><span class="p">(),</span> <span class="n">osg</span><span class="o">::</span><span class="n">Vec3</span><span class="p">(</span><span class="mf">400.0f</span><span class="p">,</span> <span class="mf">20.0f</span><span class="p">,</span> <span class="mf">20.0f</span><span class="p">))</span>
<span class="p">);</span>
<span class="n">text</span><span class="o">-&gt;</span><span class="n">setUpdateCallback</span><span class="p">(</span> <span class="k">new</span> <span class="n">UpdateTextCallback</span> <span class="p">);</span>
</pre></div>
</div>
<ol class="arabic simple" start="10">
<li><p>将文本对象添加到osg::Geode节点并关闭灯光。在启动查看器之前，我们同时需要确保场景被渲染到固定尺寸的窗口中。这是因为我们同时需要使用控制台窗口用于键盘输入：</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">osg</span><span class="o">::</span><span class="n">ref_ptr</span><span class="o">&lt;</span><span class="n">osg</span><span class="o">::</span><span class="n">Geode</span><span class="o">&gt;</span> <span class="n">geode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">osg</span><span class="o">::</span><span class="n">Geode</span><span class="p">;</span>
<span class="n">geode</span><span class="o">-&gt;</span><span class="n">addDrawable</span><span class="p">(</span> <span class="n">text</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="p">);</span>
<span class="n">geode</span><span class="o">-&gt;</span><span class="n">getOrCreateStateSet</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">setMode</span><span class="p">(</span>
    <span class="n">GL_LIGHTING</span><span class="p">,</span> <span class="n">osg</span><span class="o">::</span><span class="n">StateAttribute</span><span class="o">::</span><span class="n">OFF</span> <span class="p">);</span>
<span class="n">osgViewer</span><span class="o">::</span><span class="n">Viewer</span> <span class="n">viewer</span><span class="p">;</span>
<span class="n">viewer</span><span class="p">.</span><span class="n">setSceneData</span><span class="p">(</span> <span class="n">geode</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="p">);</span>
<span class="n">viewer</span><span class="p">.</span><span class="n">setUpViewInWindow</span><span class="p">(</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">480</span> <span class="p">);</span>
</pre></div>
</div>
<ol class="arabic simple" start="11">
<li><p>在查看器运行之前启动数据接收器，并在之后退出：</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">DataReceiverThread</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">startThread</span><span class="p">();</span>
<span class="n">viewer</span><span class="p">.</span><span class="n">run</span><span class="p">();</span>
<span class="n">DataReceiverThread</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">cancel</span><span class="p">();</span>
<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<ol class="arabic simple" start="12">
<li><p>如果我们使用子系统控制台编译我们的工程，则会出现两个窗口。将焦点放在控制台窗口中并输入一些字符。当我们完成时输入回车，并在回车后按下Tab以退出接收者线程：</p></li>
</ol>
<img alt="_images/osg_threads_console.png" src="_images/osg_threads_console.png" />
<ol class="arabic simple" start="13">
<li><p>我们将会注意到相同的字符出现在OSG渲染窗口中。这可以被看作一个非常基本的文本编辑器，文本源位于一个单独的接收线程中，而绘制界面则是在OSG场景图中实现的：</p></li>
</ol>
<img alt="_images/osg_threads_window.png" src="_images/osg_threads_window.png" />
</div>
<div class="section" id="what-just-happened">
<h3>What just happened?<a class="headerlink" href="#what-just-happened" title="Permalink to this headline">¶</a></h3>
<p>介绍线程与多线程编程超出了本书的范围。然而，使用单独的线程来由磁盘或是局域网载入大文件已经非常常见。其他一些程序使用线程来持续接收来自网络服务或客户端计算机的数据，或是用户定义输入设备，包括GPS与雷达信号，这会极大的改善速度与效率。其余的数据处理线程甚至可以指定要其上进行处理的处理器，从而可以利用今天双核心与四核CPU。</p>
<p>OpenThreads库为OSG开发者甚至是普通的C++线程程序员提供了一个最小但完整的面向对象线程接口。他被osgViewer库用来实现多线程场景更新、裁剪与绘制，这是OSG中高效渲染的秘密。在这里要注意，多线程渲染并不简单指在单独的线程中执行OpenGL调用，因为相关的渲染环境（在Win32下为HGLRC）是线程相关的。一个OpenGL环境只能位于一个线程中（使用wglMakeCurrent()函数）。所以，仅封装一个OpenGL环境的OSG渲染窗口在多线程中不会被激活和接受异步OpenGL调用。他要求对线程模型的精确控制来使得一切运行良好。</p>
</div>
<div class="section" id="pop-quiz-carefully-blocking-threads">
<h3>Pop quiz - carefully blocking threads<a class="headerlink" href="#pop-quiz-carefully-blocking-threads" title="Permalink to this headline">¶</a></h3>
<p>存在一个同时用在DataReceiverThread类示例中的addToContent()与getContent()方法中的互斥对象。他可以阻止不同的线程同时访问相同的数据。我们是否可以指出两个方法同时处理冲突的_content变量的最可能时刻吗？如果这里我们没有使用互斥会发生什么情况呢？</p>
</div>
</div>
<div class="section" id="understanding-multithreaded-readering">
<h2>Understanding multithreaded readering<a class="headerlink" href="#understanding-multithreaded-readering" title="Permalink to this headline">¶</a></h2>
<p>实时渲染的传统方法总是涉及到三个单独步骤：用户更新（UPDATE），场景裁剪（CULL）以及执行OpenGL调用（DRAW）。</p>
<p>用户更新包括各种类型的动态数据修改与操作，例如修改场景图层次结构，载入文件，骨骼顶点动画，以及更新相机位置与属性。然后他将场景图发送到裁剪阶段，在该阶段，出于改善最终渲染性的目的，场景会被重新构建。在查看截面不可见或是出于某种原因隐藏的对象将会被移除，而其余部分会由渲染状态进行排序并推送到绘制列表。该列表会在最后的绘制阶段进行遍历，而所有的OpenGL命令将会被执行来进行图像管线的处理。</p>
<p>一个单处理器系统需要串行处理所有三个阶段，从而导致一帧对于用户需求过长的情况。</p>
<p>在一个多处理器与多显示设备的系统中，我们可以有多个并行的裁剪与绘制任务来加快帧速率。特别是当管理多个渲染窗口时，为每个窗口生成一个处理裁剪与绘制阶段的新线程模型是必需的，并且同时执行。当然，这样会比仅使用一个线程要高效得多。</p>
<div class="section" id="time-for-action-switching-between-different-threading-models">
<h3>Time for action - switching between different threading models<a class="headerlink" href="#time-for-action-switching-between-different-threading-models" title="Permalink to this headline">¶</a></h3>
<p>OSG提供了非常方便的接口用于选择线程模型。不同的线程模型可以用于不同的环境，并有不同的效率。在此示例中，我们将会显示当运行一个具有大量四边形几何体的场景，在osgViewer::CompisteViewer的三个渲染窗口同时运行时，三个常用线程模型之间的区别。</p>
<ol class="arabic simple">
<li><p>包含必须的头文件：</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;osg/Group&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;osgDB/ReadFile&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;osgViewer/ViewerEventHandlers&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;osgViewer/CompositeViewer&gt;</span><span class="cp"></span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>四边形可以使用osg::createTexturedQuadGeometry()函数生成。其位置简单的通过一个随机数生成器确定。这样的一个四边形不会占用过多的系统资源。但是大量没有使用对象共享机制的四边形将会很快耗尽系统与视频卡内存（由于每一个几何体显示列表的构建），这对于测试系统负载容量非常有帮助：</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#define RAND(min, max) \</span>
<span class="cp">        ((min) + (float)rand()/(RAND_MAX+1) * ((max)-(min)))</span>
<span class="n">osg</span><span class="o">::</span><span class="n">Geode</span><span class="o">*</span> <span class="n">createMassiveQuads</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">number</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">osg</span><span class="o">::</span><span class="n">ref_ptr</span><span class="o">&lt;</span><span class="n">osg</span><span class="o">::</span><span class="n">Geode</span><span class="o">&gt;</span> <span class="n">geode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">osg</span><span class="o">::</span><span class="n">Geode</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">number</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">osg</span><span class="o">::</span><span class="n">Vec3</span> <span class="n">randomCenter</span><span class="p">;</span>
        <span class="n">randomCenter</span><span class="p">.</span><span class="n">x</span><span class="p">()</span> <span class="o">=</span> <span class="n">RAND</span><span class="p">(</span><span class="o">-</span><span class="mf">100.0f</span><span class="p">,</span> <span class="mf">100.0f</span><span class="p">);</span>
        <span class="n">randomCenter</span><span class="p">.</span><span class="n">y</span><span class="p">()</span> <span class="o">=</span> <span class="n">RAND</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">100.0f</span><span class="p">);</span>
        <span class="n">randomCenter</span><span class="p">.</span><span class="n">z</span><span class="p">()</span> <span class="o">=</span> <span class="n">RAND</span><span class="p">(</span><span class="o">-</span><span class="mf">100.0f</span><span class="p">,</span> <span class="mf">100.0f</span><span class="p">);</span>

        <span class="n">osg</span><span class="o">::</span><span class="n">ref_ptr</span><span class="o">&lt;</span><span class="n">osg</span><span class="o">::</span><span class="n">Drawable</span><span class="o">&gt;</span> <span class="n">quad</span> <span class="o">=</span>
            <span class="n">osg</span><span class="o">::</span><span class="n">createTexturedQuadGeometry</span><span class="p">(</span>
                <span class="n">randomCenter</span><span class="p">,</span>
                <span class="n">osg</span><span class="o">::</span><span class="n">Vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">),</span>
                <span class="n">osg</span><span class="o">::</span><span class="n">Vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">)</span>
            <span class="p">);</span>
        <span class="n">geode</span><span class="o">-&gt;</span><span class="n">addDrawable</span><span class="p">(</span> <span class="n">quad</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">geode</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<ol class="arabic simple" start="3">
<li><p>组合查看器对于每个渲染窗口需要一个单独的osgViewer::View实例。窗口的位置与大小是由setUpViewInWindow()方法确定的：</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">osgViewer</span><span class="o">::</span><span class="n">View</span><span class="o">*</span> <span class="n">createView</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">w</span><span class="p">,</span> <span class="kt">int</span> <span class="n">h</span><span class="p">,</span>
                             <span class="n">osg</span><span class="o">::</span><span class="n">Node</span><span class="o">*</span> <span class="n">scene</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">osg</span><span class="o">::</span><span class="n">ref_ptr</span><span class="o">&lt;</span><span class="n">osgViewer</span><span class="o">::</span><span class="n">View</span><span class="o">&gt;</span> <span class="n">view</span> <span class="o">=</span> <span class="k">new</span> <span class="n">osgViewer</span><span class="o">::</span><span class="n">View</span><span class="p">;</span>
    <span class="n">view</span><span class="o">-&gt;</span><span class="n">setSceneData</span><span class="p">(</span> <span class="n">scene</span> <span class="p">);</span>
    <span class="n">view</span><span class="o">-&gt;</span><span class="n">setUpViewInWindow</span><span class="p">(</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="p">);</span>
    <span class="k">return</span> <span class="n">view</span><span class="p">.</span><span class="n">release</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<ol class="arabic simple" start="4">
<li><p>在主体部分，我们首先使用一个参数解析器来选择线程模型。默认情况下，OSG会依据处理器与程序的渲染窗口的数量自动选择最佳的线程策略，也就是AutomaticSelection。但是我们仍然由内建值中指定一种处理多线程渲染的方法，包括SingleThreaded，ThreadPerContext与ThreadPerCamera：</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">osg</span><span class="o">::</span><span class="n">ArgumentParser</span> <span class="n">arguments</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span> <span class="p">);</span>
<span class="n">osgViewer</span><span class="o">::</span><span class="n">ViewerBase</span><span class="o">::</span><span class="n">ThreadingModel</span> <span class="n">th</span> <span class="o">=</span>
    <span class="n">osgViewer</span><span class="o">::</span><span class="n">ViewerBase</span><span class="o">::</span><span class="n">AutomaticSelection</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span> <span class="n">arguments</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="s">&quot;--single&quot;</span><span class="p">)</span> <span class="p">)</span> <span class="n">th</span> <span class="o">=</span>
    <span class="n">osgViewer</span><span class="o">::</span><span class="n">ViewerBase</span><span class="o">::</span><span class="n">SingleThreaded</span><span class="p">;</span>
<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span> <span class="n">arguments</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="s">&quot;--useContext&quot;</span><span class="p">)</span> <span class="p">)</span> <span class="n">th</span> <span class="o">=</span>
    <span class="n">osgViewer</span><span class="o">::</span><span class="n">ViewerBase</span><span class="o">::</span><span class="n">ThreadPerContext</span><span class="p">;</span>
<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span> <span class="n">arguments</span><span class="p">.</span><span class="n">read</span><span class="p">(</span><span class="s">&quot;--useCamera&quot;</span><span class="p">)</span> <span class="p">)</span> <span class="n">th</span> <span class="o">=</span>
    <span class="n">osgViewer</span><span class="o">::</span><span class="n">ViewerBase</span><span class="o">::</span><span class="n">ThreadPerCamera</span><span class="p">;</span>
</pre></div>
</div>
<ol class="arabic simple" start="5">
<li><p>创建三个渲染视图并将大量的四边形几何体应用到其中的每一个。在该示例中总计分配了20000个四边形用于演示不同的线程模型：</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">osgViewer</span><span class="o">::</span><span class="n">View</span><span class="o">*</span> <span class="n">view1</span> <span class="o">=</span> <span class="n">createView</span><span class="p">(</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">640</span><span class="p">,</span> <span class="mi">480</span><span class="p">,</span>
    <span class="n">createMassiveQuads</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span> <span class="p">);</span>
<span class="n">osgViewer</span><span class="o">::</span><span class="n">View</span><span class="o">*</span> <span class="n">view2</span> <span class="o">=</span> <span class="n">createView</span><span class="p">(</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">550</span><span class="p">,</span> <span class="mi">320</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span>
    <span class="n">createMassiveQuads</span><span class="p">(</span><span class="mi">5000</span><span class="p">)</span> <span class="p">);</span>
<span class="n">osgViewer</span><span class="o">::</span><span class="n">View</span><span class="o">*</span> <span class="n">view3</span> <span class="o">=</span> <span class="n">createView</span><span class="p">(</span> <span class="mi">370</span><span class="p">,</span> <span class="mi">550</span><span class="p">,</span> <span class="mi">320</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span>
    <span class="n">createMassiveQuads</span><span class="p">(</span><span class="mi">5000</span><span class="p">)</span> <span class="p">);</span>
<span class="n">view1</span><span class="o">-&gt;</span><span class="n">addEventHandler</span><span class="p">(</span> <span class="k">new</span> <span class="n">osgViewer</span><span class="o">::</span><span class="n">StatsHandler</span> <span class="p">);</span>
</pre></div>
</div>
<ol class="arabic simple" start="6">
<li><p>创建组合查看器并设置用户指定的线程模型。注意，这里的setThreadingModel()方法不仅能用于osgViewer::CompositeViewer，而且对于大多数普通的osgViewer::Viewer实例也是可用的：</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">osgViewer</span><span class="o">::</span><span class="n">CompositeViewer</span> <span class="n">viewer</span><span class="p">;</span>
<span class="n">viewer</span><span class="p">.</span><span class="n">setThreadingModel</span><span class="p">(</span> <span class="n">th</span> <span class="p">);</span>
<span class="n">viewer</span><span class="p">.</span><span class="n">addView</span><span class="p">(</span> <span class="n">view1</span> <span class="p">);</span>
<span class="n">viewer</span><span class="p">.</span><span class="n">addView</span><span class="p">(</span> <span class="n">view2</span> <span class="p">);</span>
<span class="n">viewer</span><span class="p">.</span><span class="n">addView</span><span class="p">(</span> <span class="n">view3</span> <span class="p">);</span>
<span class="k">return</span> <span class="n">viewer</span><span class="p">.</span><span class="n">run</span><span class="p">();</span>
</pre></div>
</div>
<ol class="arabic simple" start="7">
<li><p>编译程序（假定其名字为MyProject.exe）并在控制台模式下输入下面命令：</p></li>
</ol>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp"># MyProject.exe --single</span>
</pre></div>
</div>
<ol class="arabic simple" start="8">
<li><p>最终的结果如下图所示。注意对于单线程模型帧速率仅为20，其中，更新、裁剪与绘制阶段是在相同的线程中依次完成的：</p></li>
</ol>
<img alt="_images/osg_multithread_single.png" src="_images/osg_multithread_single.png" />
<ol class="arabic simple" start="9">
<li><p>将参数由–single改变–useContext并再次启动测试程序。这次我们将会发现帧速率增加了。这是因为OSG除了用户更新阶段，对于裁剪与绘制阶段使用单独的线程，从而大大的改进了渲染性能：</p></li>
</ol>
<img alt="_images/osg_multithread_context.png" src="_images/osg_multithread_context.png" />
<ol class="arabic simple" start="10">
<li><p>将命令行参数修改为–useCamera并再次启动测试程序。这际上是对于现令大多数多处理器计算机的默认策略。他甚至好于第二种线程模型，因为他对于相机与渲染窗口使用不同的线程，并在单独的CPU上运行线程以获得最大的效率：</p></li>
</ol>
<img alt="_images/osg_multithread_camera.png" src="_images/osg_multithread_camera.png" />
</div>
<div class="section" id="id1">
<h3>What just happened?<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>SingleThreaded线程模型可以表示为下图。每个渲染窗口中的CULL与DRAW阶段也许会有不同的聚合时间，在这里一帧被定义为由每一个视图的CULL开始直到最后一个视图的DRAW为止的总时间。在这里忽略了用户更新操作，因为在所有的线程模型中他们总是占用相同的聚合时间：</p>
<img alt="_images/osg_threads_frame.png" src="_images/osg_threads_frame.png" />
<p>更新、裁剪与绘制操作总是在一个线程内执行。如果有多个子视图，也就是，多个裁剪与绘制任务要完成，那么他们就会被依次执行。这是OSG中渲染场景最高效的模型，但是对于测试新功能依然有用。同时他也简化了与GUI的集成，例如MFC与Qt。因为我们并不关心线程冲突，所以我们可以仅将osgViewer::Viewer或osgViewer::CompositeViewer的run()方法放在GUI计时器事件回调中，而不需要使用额外的线程，正如我们在第9章所做的那样。</p>
<p>ThreadPerContext模型可以直接由下图进行表示：</p>
<img alt="_images/osg_threads_context.png" src="_images/osg_threads_context.png" />
<p>每个组合查看器的子视图有其自己的线程，在其中执行裁剪与绘制任务。由于线程的并行特性，每一个帧的执行时间将会短于最长CULL与DRAW对的总时间。在所有的DRAW任务完成之后，下一帧的用户更新将会立即启动。</p>
<p>这在渲染性能方面要好于单线程模型。他甚至可以利用多处理器，因为每个线程可以占用单独的处理器，以最大化硬件资源的使用。</p>
<p>然而，更好的解决方案是ThreadPerCamera模型。这会将每个视图的CULL阶段与DRAW阶段分开，同时在线程中实现。这意味着对于每个渲染窗口我们至少有一个CULL线程与一个DRAW线程，因而可以完全利用多处理器系统。因为裁剪操作一定与osg::Camera节点相关（他为视图截图裁剪管理视图与投影矩阵），我们将该线程模型称为“每个相机一个线程”模型，如下图所示：</p>
<img alt="_images/osg_threads_camera.png" src="_images/osg_threads_camera.png" />
<p>在线程模型中，DRAW阶段被看作两个并行处理，在CPU端分民命令，而在GPU端执行渲染缓冲区交换并执行。交换缓冲区操作的时间消耗可以是统一的，并且在所有的DRAW分发操作完成之后执行。但是在这之前，线程模型会预告启动下一帧的用户UPDATE阶段。这种处理再一次极大的改善了渲染性能，但是如果用户更新改变正在被分发的场景数据，也许会导致未预期的结果。这也正是我们为也许会被修改的场景对象设置动态标记的原因：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">node</span><span class="o">-&gt;</span><span class="n">setDataVariance</span><span class="p">(</span> <span class="n">osg</span><span class="o">::</span><span class="n">Object</span><span class="o">::</span><span class="n">DYNAMIC</span> <span class="p">);</span>
</pre></div>
</div>
<p>默认情况，如果检测到多处理器系统，OSG将会支持ThreadPerCamera线程模型。</p>
</div>
</div>
<div class="section" id="dynamic-scene-culling">
<h2>Dynamic scene culling<a class="headerlink" href="#dynamic-scene-culling" title="Permalink to this headline">¶</a></h2>
<p>裁剪技术可以进行简单的描述：不绘制我们看不见的东西。我们可以使用两种主要方法实现该目的：通过减少不需要进行细化的多边形面，以及忽略当前视口中不可见的对象。</p>
<p>前者通常是由LOD（level-of-detail）算法实现的，在OSG中是通过osg::LOD类实现的。后者实际上是场景裁剪的定义，目的是查找场景图中根本不需要渲染的对象。在OSG中有多种裁剪技术类型：</p>
<ul class="simple">
<li><p>背面裁剪（Back face culling）：这是由osg::CullFace类实现的，该类封装了OpenGL的glCullFace()函数。他会由渲染管线的相机中移除所有多边形面，从而减少内存占用。这种技术很有用，特别是对于复杂的对象，但是对于透明的物体或是有洞的物体也许会有错误。</p></li>
<li><p>小特性裁剪（Smallfeature culling）：该技术会基于可见性测试允许过小而看不见的对象的移除，结果导致如果绘制对象则会影响对象的像素数。如果该数目小于用户定义的最小像素阈值，则该对象会由渲染列表中移除。</p></li>
<li><p>视图截面裁剪（View-frustum culling）：其思想只是简单的不渲染超出由渲染窗口的视图与投影矩阵所定义的视图截面的部分。这是现代渲染程序中最高效的方法。</p></li>
<li><p>闭合裁剪（Occlusion culling）：该技术会确定由于隐藏在其他对象之后，哪些对象会完全不可见。我们很快会在下一节进行讨论。</p></li>
</ul>
<p>注意，小特性裁剪方法也许会导致实际的实际的几何体点不可渲染。要禁止该特性，我们可以使用相机节点的setCullingMode()方法：</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">camera</span><span class="o">-&gt;</span><span class="n">setCullingMode</span><span class="p">(</span>
   <span class="n">camera</span><span class="o">-&gt;</span><span class="n">getCullingMode</span><span class="p">()</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">osg</span><span class="o">::</span><span class="n">Camera</span><span class="o">::</span><span class="n">SMALL_FEATURE_CULLING</span> <span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="occluders-and-occludees">
<h2>Occluders and occludees<a class="headerlink" href="#occluders-and-occludees" title="Permalink to this headline">¶</a></h2>
<p>当渲染复杂的场景时，由查看者的视角来看，两个或多个对象彼此重叠是很常见的现象。这会导致重复绘制，这意味着当最终的图片仅显示最后一个对象时，相同位置的像素会被多次写入帧缓冲区。这会导致效率损失，因为多次绘制并没有必要（所谓的覆盖绘制）。</p>
<p>闭合裁剪技术简单的通过不绘制为距离相机更近的对象所隐藏的几何体来提高渲染性能。覆盖其他可绘制元素的对象被称之为遮光板，而场景的其余部分可以被看作非遮光区域（未没有必要使用这样不熟悉的单词）。</p>
</div>
<div class="section" id="improving-your-application">
<h2>Improving your application<a class="headerlink" href="#improving-your-application" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="paging-huge-scene-data">
<h2>Paging huge scene data<a class="headerlink" href="#paging-huge-scene-data" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="making-use-of-the-quad-tree">
<h2>Making use of the quad-tree<a class="headerlink" href="#making-use-of-the-quad-tree" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
</div>
</div>






<div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'osg3'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="ch11.html" class="btn btn-neutral" title="Chapter 11: Developing Visual Components"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2013, mylxiaoyi.
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.01',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="_static/language_data.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
  
 




<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', ]);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>



</body>
</html>